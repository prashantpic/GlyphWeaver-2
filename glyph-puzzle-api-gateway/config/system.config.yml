# General system configuration
# logLevel: ${process.env.LOG_LEVEL:-info} # Default log level (debug, info, warn, error)
# Express Gateway default logging is console. For more advanced logging (e.g., to file, ELK),
# you might need a custom logging plugin or specific EG configuration.
# watch: ${process.env.NODE_ENV !== 'production'} # Enable config hot-reloading in dev

# Redis configuration for Express Gateway built-in policies (e.g., rate-limit, circuit-breaker with redis driver)
# Also used by custom redis.client.ts if it reads from EG's config, though it can also use direct env vars.
redis:
  # Common options for ioredis, check Express Gateway documentation for specific usage
  # For Express Gateway policies, the configuration might be simpler or specific to EG's Redis integration.
  # If using ioredis directly (e.g. in custom policies/plugins), these options are standard.
  url: ${process.env.REDIS_URL:-redis://localhost:6379}
  # Example additional ioredis options:
  # host: ${process.env.REDIS_HOST:-localhost}
  # port: ${process.env.REDIS_PORT:-6379}
  # password: ${process.env.REDIS_PASSWORD}
  # db: ${process.env.REDIS_DB:-0}
  # prefix: 'eg:' # Optional prefix for keys used by Express Gateway

# Plugin registration and configuration
plugins:
  swaggerPlugin:
    package: ./plugins/swagger.plugin.js # Path should be relative to gateway root or node_modules
    # Note: If using TypeScript, ensure plugins are compiled to JS and path points to JS file.
    # EG typically loads JS files. Consider build step to output JS to a 'dist' and adjust paths.
    # Or, if ts-node is used for dev, TS paths might work directly if EG is started via ts-node.
    # For production, JS paths are safer. Assuming a build step compiles TS to JS in a similar structure.
    # Example: package: '../dist/src/plugins/swagger.plugin.js' if gateway.config.yml is in 'dist/config'
    config:
      swaggerUiPath: '/api-docs' # Base path for Swagger UI
      # swaggerFilePath: './public/openapi.yml' # Path to OpenAPI spec, relative to plugin or absolute

  serviceDiscoveryPlugin:
    package: ./plugins/service-discovery.plugin.js
    config:
      providerUrl: ${process.env.SERVICE_DISCOVERY_PROVIDER_URL}
      servicesToDiscover: # Array of serviceEndpoint names from gateway.config.yml
        - backendService
      pollingIntervalMs: ${process.env.SERVICE_DISCOVERY_POLL_INTERVAL_MS:-30000} # e.g., 30 seconds

  canaryRoutingPlugin:
    package: ./plugins/canary-routing.plugin.js
    config:
      # Example configuration for weighted routing
      # This config structure depends on how canary.plugin.ts is implemented
      defaultWeightKey: 'weight' # Default key for percentage if not specified per route
      routes:
        - apiEndpointName: 'apiV1' # Matches apiEndpoint name in gateway.config.yml
          serviceEndpoint: 'backendService' # Stable service name
          canaryServiceEndpoint: 'backendServiceCanary' # Canary service name (define in gateway.config.yml)
          # Routing strategy: 'weight' or 'header'
          strategy: 'weight'
          weight: ${process.env.CANARY_TRAFFIC_PERCENTAGE:-5} # 0-100, percentage to canary
        # Example: Header-based canary routing for a specific API endpoint or path prefix
        # - apiPathPrefix: '/v1/experimental/'
        #   serviceEndpoint: 'backendService'
        #   canaryServiceEndpoint: 'backendServiceCanary'
        #   strategy: 'header'
        #   headerName: 'X-Canary-Request'
        #   headerValue: 'true'

# Policy registration (for custom policies)
# Express Gateway typically discovers policies if they are in the ./policies directory
# and named correctly (e.g., jwtAuthPolicy.js exporting the policy object).
# Explicit registration here is usually not needed unless paths are non-standard
# or you want to alias them.
#
# policies:
#   jwtAuthPolicy:
#     package: ./policies/jwt.policy.js
#   customRequestValidationPolicy:
#     package: ./policies/custom-request-validation.policy.js
#   requestTransformerPolicy:
#     package: ./policies/request-transformer.policy.js
#   responseTransformerPolicy:
#     package: ./policies/response-transformer.policy.js
#   errorHandlerPolicy:
#     package: ./policies/error-handler.policy.js

# Note on paths for policies and plugins:
# If your `system.config.yml` and `gateway.config.yml` are in a `config` directory,
# and your compiled JS code (from TS) is in a `dist` directory at the root,
# then paths like `./plugins/swagger.plugin.js` might need to be `../dist/plugins/swagger.plugin.js`
# or similar, depending on where EG is run from and how it resolves relative paths.
# This example assumes the compiled structure mirrors the src structure (e.g., dist/plugins, dist/policies)
# and EG is run from the project root where `dist` is a subdirectory.
# If running directly from `src` using `ts-node` in development, paths would be relative to `src`.
# The current `./plugins/...` assumes system.config.yml is at the root, and plugins are in a root `plugins` dir.
# Adjust these paths based on your actual compiled output structure and runtime directory.
# A common practice is to have a `dist` folder, and run `node dist/index.js`.
# If `index.js` loads configs from `dist/config`, then paths in config files should be relative from there.
# The SDS implies policies are in `src/policies` and plugins in `src/plugins`.
# If built to `dist/src/policies` and `dist/src/plugins`, and config is in `dist/config`,
# paths would be `../src/plugins/...` (referring to the compiled JS files, not TS).
# For simplicity, this example uses `./plugins/` assuming a flat structure or correct CWD.
# More robustly, use paths relative to project root after compilation.
# Example if running from project root and compiled files are in `dist`:
# package: './dist/plugins/swagger.plugin.js'
# package: './dist/policies/jwt.policy.js'
# Given the project structure, if system.config.yml is in ./config, and compiled plugins are in ./dist/plugins,
# then a path like '../dist/plugins/swagger.plugin.js' would be appropriate.
# For now, using relative paths assuming a specific runtime CWD that aligns with these paths.
# A common setup is that the config files are copied into the 'dist' directory,
# so paths would be relative from 'dist/config' to 'dist/plugins', e.g., '../plugins/swagger.plugin.js'.
# The current structure uses package: './plugins/...' - assuming they are compiled to a root-level `plugins` directory.
# Let's adjust to common `dist` structure.
# If system.config.yml is in `./config` and plugins are compiled to `./dist/src/plugins`,
# and the gateway starts from project root with configs loaded from `./config`,
# then paths to compiled JS in `dist` would be like:
# package: './dist/src/plugins/swagger.plugin.js'
#
# However, the prompt output these files previously as `src/plugins/swagger.plugin.ts`
# which implies ts-node or similar for direct TS execution, or manual compilation.
# For this iteration, I will assume the paths in the prompt's example are how EG resolves them for TS files with ts-node,
# or they are placeholders to be replaced with .js paths after compilation.
# The SDS specifies `.ts` paths for plugins and policies.
# Using the `.ts` paths as per SDS and previous prompt example output for this iteration.