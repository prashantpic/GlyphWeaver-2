# Software Design Specification (SDS) for REPO-GLYPH-GAMECONTENT

## 1. Introduction

### 1.1. Purpose

This document provides a detailed software design for the **Game Content API Endpoint** (`REPO-GLYPH-GAMECONTENT`). The primary function of this service is to provide RESTful API endpoints for managing game content. Its core responsibility is to allow the game client to register the parameters of a procedurally generated level instance. This stored data enables level reproduction for verification, debugging, player support, and cheat detection, as stipulated in requirements `REQ-CGLE-011` and `REQ-8-027`.

### 1.2. Scope

This design covers the backend service responsible for:
- Exposing a secure endpoint to register procedurally generated level data.
- Validating and persisting this data into a MongoDB database.
- Defining the data models and schemas for game content entities.
- Providing a foundation for future endpoints to serve hand-crafted level data.

The technology stack is Node.js, Express.js, TypeScript, MongoDB (with Mongoose), and Joi for validation.

## 2. System Architecture

This service follows a **Layered Architecture** to ensure separation of concerns, maintainability, and testability.

-   **Presentation Layer**: Responsible for handling HTTP requests and responses. This includes API routes (Express Routers), controllers, Data Transfer Objects (DTOs), and request validation logic (Joi). It translates HTTP requests into application-specific commands.
-   **Application Services Layer**: Contains the core business logic and orchestrates use cases. It acts as an intermediary between the presentation and data access layers, ensuring that business rules are enforced.
-   **Data Access Layer**: Manages all interactions with the MongoDB database. This layer includes Mongoose models that define the data schema and Repositories that abstract the database queries.

## 3. API Endpoint Specification

### 3.1. Register Procedural Level Instance

This endpoint allows an authenticated client to submit the data for a procedurally generated level they have just encountered, receiving a unique ID for that instance.

-   **Endpoint**: `POST /api/v1/procedural-levels/register`
-   **Description**: Creates and stores a new procedural level instance.
-   **Authentication**: Required. The request must include a valid JWT in the `Authorization` header (`Bearer <token>`). The JWT payload must contain the `playerId`.
-   **Request Body**:
    -   Content-Type: `application/json`
    -   Structure: See `RegisterLevelDto` in Section 5.3.1.
    -   Validation: The body is validated against the `registerLevelSchema` (See Section 5.6.1).
-   **Responses**:
    -   **201 Created**: Successful registration. The response body will contain the unique ID of the created level instance.
        -   Body Structure: See `LevelInstanceResponseDto` in Section 5.3.2.
    -   **400 Bad Request**: The request body fails validation (e.g., missing fields, incorrect data types). The response body will contain a descriptive error message.
    -   **401 Unauthorized**: No JWT or an invalid JWT was provided.
    -   **500 Internal Server Error**: An unexpected error occurred on the server (e.g., database connection issue).

## 4. Data Model Specification

### 4.1. `procedurallevels` Collection

This MongoDB collection stores individual instances of procedurally generated levels.

-   **`procedural-level.model.ts`**: The Mongoose model definition.
-   **Schema**:
    | Field Name | Type | Required | Description |
    | :--- | :--- | :--- | :--- |
    | `_id` | `ObjectId` | Yes | Auto-generated unique identifier for the document. |
    | `playerId` | `ObjectId` | Yes | The ID of the `PlayerProfile` who generated/played this level. |
    | `baseLevelId` | `String` | Yes | The ID of the handcrafted level template this was generated from. |
    | `generationSeed`| `String` | Yes | The seed used to generate the level, allowing for exact reproduction. |
    | `generationParameters` | `Object` | Yes | A JSON object containing all parameters used by the generation algorithm (e.g., grid size, obstacle count). |
    | `solutionPath`| `Object` | Yes | A JSON object representing at least one valid solution path for the generated level. |
    | `complexityScore` | `Number` | Yes | The calculated complexity score for this specific instance. |
    | `createdAt` | `Date` | Yes | Timestamp of document creation (managed by Mongoose). |
    | `updatedAt` | `Date` | Yes | Timestamp of last document update (managed by Mongoose). |

-   **Indexes**:
    -   An index on `playerId` to quickly find levels generated by a specific player.
    -   An index on `baseLevelId` to find instances generated from a specific template.

## 5. Component Design

### 5.1. Configuration

#### 5.1.1. `package.json`
-   **Purpose**: Manages project dependencies and scripts.
-   **Dependencies**: `express`, `mongoose`, `joi`, `jsonwebtoken`, `dotenv`, `cors`.
-   **Dev Dependencies**: `typescript`, `ts-node-dev`, `@types/*`, `jest`, `supertest`.
-   **Scripts**:
    -   `start:dev`: `ts-node-dev src/server.ts` - Runs the server in development mode with live-reloading.
    -   `build`: `tsc` - Compiles TypeScript to JavaScript in the `dist/` directory.
    -   `start`: `node dist/server.js` - Runs the compiled application for production.
    -   `test`: `jest` - Runs unit and integration tests.

#### 5.1.2. `tsconfig.json`
-   **Purpose**: Configures the TypeScript compiler.
-   **Key Options**: `target: "ES2020"`, `module: "commonjs"`, `outDir: "./dist"`, `rootDir: "./src"`, `strict: true`, `esModuleInterop: true`.

#### 5.1.3. `src/config/index.ts`
-   **Purpose**: Provides type-safe application configuration from environment variables.
-   **Logic**:
    -   Uses `dotenv` to load `.env` file in non-production environments.
    -   Validates the presence of required environment variables (`PORT`, `MONGODB_URI`, `JWT_SECRET`). Throws an error on startup if any are missing.
    -   Exports a frozen object with all configuration values.

### 5.2. Middleware

#### 5.2.1. `src/middleware/auth.middleware.ts`
-   **Purpose**: Secures API endpoints by validating JWTs.
-   **Function**: `authenticate(req: Request, res: Response, next: NextFunction)`
-   **Logic**:
    1.  Check for `Authorization` header and ensure it starts with `Bearer `.
    2.  If missing or malformed, return a `401 Unauthorized` error.
    3.  Extract the token string.
    4.  Use `jsonwebtoken.verify()` with the `JWT_SECRET` from config to validate the token.
    5.  On success, attach the decoded payload (which should include `playerId`) to a custom property on the `Request` object (e.g., `req.user`).
    6.  Call `next()` to proceed to the next middleware or controller.
    7.  If verification fails (e.g., expired token, invalid signature), return a `401 Unauthorized` error.

### 5.3. Presentation Layer Components

#### 5.3.1. `src/api/v1/procedural-levels/dto/register-level.dto.ts`
-   **Purpose**: Defines the request payload structure.
-   **Implementation**: A TypeScript interface or class.
    typescript
    export interface RegisterLevelDto {
      readonly baseLevelId: string;
      readonly generationSeed: string;
      readonly generationParameters: Record<string, any>;
      readonly solutionPath: Record<string, any>;
      readonly complexityScore: number;
    }
    

#### 5.3.2. `src/api/v1/procedural-levels/dto/level-instance.response.dto.ts`
-   **Purpose**: Defines the successful response payload structure.
-   **Implementation**: A TypeScript interface or class.
    typescript
    export interface LevelInstanceResponseDto {
      readonly proceduralLevelId: string;
    }
    

#### 5.3.3. `src/api/v1/procedural-levels/procedural-levels.validation.ts`
-   **Purpose**: Defines request body validation rules using Joi.
-   **Implementation**:
    typescript
    import Joi from 'joi';

    export const registerLevelSchema = Joi.object({
      baseLevelId: Joi.string().required(),
      generationSeed: Joi.string().required(),
      generationParameters: Joi.object().required(),
      solutionPath: Joi.object().required(),
      complexityScore: Joi.number().required(),
    });
    

#### 5.3.4. `src/api/v1/procedural-levels/procedural-levels.controller.ts`
-   **Purpose**: Handles HTTP request logic for the endpoint.
-   **Class**: `ProceduralLevelsController`
-   **Dependencies**: Injected `ProceduralLevelService`.
-   **Method**: `register(req: Request, res: Response, next: NextFunction): Promise<void>`
    -   **Logic**:
        1.  Extract the `playerId` from `req.user` (populated by `auth.middleware`).
        2.  Extract the validated request body (`RegisterLevelDto`).
        3.  Call `this.proceduralLevelService.registerLevel(body, playerId)`.
        4.  Await the `proceduralLevelId` from the service.
        5.  Construct a `LevelInstanceResponseDto`.
        6.  Send a `201 Created` response with the DTO.
        7.  Wrap the logic in a `try...catch` block, passing any errors to `next(error)`.

#### 5.3.5. `src/api/v1/procedural-levels/index.ts`
-   **Purpose**: Configures and exports the Express router for this feature.
-   **Logic**:
    1.  Create a new `Express.Router()`.
    2.  Instantiate the controller, service, repository, and any other dependencies.
    3.  Define the route: `router.post('/register', authenticate, validate(registerLevelSchema), controller.register.bind(controller))`.
        -   `authenticate` is the JWT middleware.
        -   `validate` is a generic middleware that uses the provided Joi schema to validate `req.body`.
    4.  Export the router.

### 5.4. Application Services Layer

#### 5.4.1. `src/services/procedural-level.service.ts`
-   **Purpose**: Encapsulates the business logic for registering a level.
-   **Class**: `ProceduralLevelService`
-   **Dependencies**: Injected `ProceduralLevelRepository` and `AuditService`.
-   **Method**: `registerLevel(levelData: RegisterLevelDto, playerId: string): Promise<string>`
    -   **Logic**:
        1.  Construct the data object for the repository, combining `levelData` with the `playerId`.
        2.  Call `this.proceduralLevelRepository.create(dataToSave)`.
        3.  Await the `createdLevel` document from the repository.
        4.  Call `this.auditService.logEvent('LEVEL_INSTANCE_REGISTERED', { playerId, proceduralLevelId: createdLevel._id })`.
        5.  Return the `createdLevel._id` as a string.

#### 5.4.2. `src/services/audit.service.ts`
-   **Purpose**: Provides a centralized way to log important system events.
-   **Class**: `AuditService` (implements `IAuditService`)
-   **Method**: `logEvent(eventType: string, details: Record<string, any>): Promise<void>`
    -   **Logic**:
        -   For now, this will simply log to the console in a structured format (e.g., JSON).
        -   `console.log(JSON.stringify({ timestamp: new Date().toISOString(), eventType, details }));`
        -   This can be extended later to write to a dedicated `AuditLog` collection in MongoDB.

### 5.5. Data Access Layer

#### 5.5.1. `src/data/models/procedural-level.model.ts`
-   **Purpose**: Defines the Mongoose schema and model.
-   **Logic**:
    1.  Import `Schema`, `model` from `mongoose`.
    2.  Define an `IProceduralLevel` interface extending `Document` with all fields from Section 4.1.
    3.  Create a `proceduralLevelSchema` using `new Schema(...)`, defining types and required constraints.
    4.  Enable timestamps: `{ timestamps: true }`.
    5.  Export the compiled model: `model<IProceduralLevel>('ProceduralLevel', proceduralLevelSchema)`.

#### 5.5.2. `src/data/repositories/procedural-level.repository.ts`
-   **Purpose**: Handles all database operations for the `procedurallevels` collection.
-   **Class**: `ProceduralLevelRepository`
-   **Dependencies**: Injected Mongoose `Model<IProceduralLevel>`.
-   **Method**: `create(levelData: Partial<IProceduralLevel>): Promise<IProceduralLevel>`
    -   **Logic**: `return new this.proceduralLevelModel(levelData).save();`
-   **Method**: `findById(id: string): Promise<IProceduralLevel | null>`
    -   **Logic**: `return this.proceduralLevelModel.findById(id).exec();`

### 5.6. Application Bootstrap

#### 5.6.1. `src/app.ts`
-   **Purpose**: Creates and configures the main Express application.
-   **Logic**:
    1.  Create an Express app instance.
    2.  Apply global middleware: `cors()`, `express.json()`.
    3.  Import and mount the procedural levels router: `app.use('/api/v1/procedural-levels', proceduralLevelsRouter)`.
    4.  Define a global error-handling middleware that catches errors passed by `next()` and sends a standardized JSON error response.
    5.  Export the configured `app`.

#### 5.6.2. `src/server.ts`
-   **Purpose**: Starts the server and connects to the database.
-   **Logic**:
    1.  Import `app` and `config`.
    2.  Define an async `startServer` function.
    3.  Inside, call `mongoose.connect(config.MONGODB_URI)`.
    4.  On successful connection, start the server: `app.listen(config.PORT, () => { ... })`.
    5.  Log a success message to the console.
    6.  Handle connection errors with `mongoose.connection.on('error', ...)` and graceful shutdown logic.
    7.  Call `startServer()`.