story_id,epic,title,user_role,description,priority,story_points,dependencies,acceptance_criteria_1,acceptance_criteria_2,acceptance_criteria_3,technical_tasks,definition_of_done
"US-1011","Project Foundation & Core Setup","Configure Project Dependencies and Scripts","Developer","As a Developer, I want a configured package.json file so that I can manage project dependencies and run common tasks like starting, building, and testing the application consistently.","Must Have",1,"","Given a fresh checkout of the project, When I run `npm install`, Then all required dependencies (express, mongoose) and dev dependencies (typescript, jest) are installed.","Given the package.json is configured, When I inspect the `scripts` section, Then it contains commands for `start`, `build`, `dev`, and `test`.","Given the project is set up, When I run `npm run dev`, Then the application starts in development mode using `nodemon` and `ts-node`.","Initialize the project with npm and create the package.json file. Add dependencies: express, mongoose, dotenv. Add dev dependencies: typescript, ts-node, nodemon, @types/node, @types/express, jest, ts-jest, supertest, mongodb-memory-server. Dependencies must match versions compatible with the chosen Node.js version.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-1012","Project Foundation & Core Setup","Configure TypeScript Compilation Rules","Developer","As a Developer, I want a `tsconfig.json` file so that TypeScript code is transpiled into JavaScript with consistent, strict rules, ensuring code quality and a predictable build output.","Must Have",1,"","Given the `tsconfig.json` file is present, When I run the `tsc` command (or `npm run build`), Then TypeScript files from the `src` directory are compiled into JavaScript files in the `dist` directory.","Given the compiler is configured for strict mode, When I write code with potential type errors (e.g., using a variable before assignment), Then the TypeScript compiler will raise an error during compilation.","Given the project structure, When I use an import statement, Then I can use modern ES module interoperability features without compilation issues.","Configure the TypeScript compiler with settings appropriate for a Node.js Express application, including target, module system, output directory, and strict type checking. Must set 'outDir' to './dist', 'rootDir' to './src', and enable 'esModuleInterop' and 'strict' mode.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-1013","Project Foundation & Core Setup","Establish Application Bootstrap and Server Entrypoint","Developer","As a Developer, I want a main application entrypoint (`index.ts`) so that the service can be started correctly, ensuring the database is connected before accepting any web requests.","Must Have",3,"US-1014,US-3011","Given the application is started with the necessary environment variables, When the database connection is successful, Then the Express server starts listening on the configured port and logs a confirmation message.","Given the application is started, When the initial database connection fails, Then the application logs a critical error and exits gracefully without starting the server.","Given the `dotenv` package is configured, When the application starts, Then it loads configuration variables (like PORT and MONGO_URI) from a `.env` file.","Create the main entry point file (`src/index.ts`). This file will be responsible for loading environment variables, initiating the database connection, and starting the Express server. Must use 'dotenv' to load environment variables. Must call the database connection module and gracefully handle connection failures.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-1014","Project Foundation & Core Setup","Set Up Core Express Application and Middleware","Developer","As a Developer, I want a centralized Express setup file (`app.ts`) so that all core middleware, routing, and error handling are configured in one place for better maintainability.","Must Have",3,"","Given the application is running, When it receives a request with a JSON body, Then the `express.json()` middleware correctly parses the body into `req.body`.","Given a route handler throws an error, When the error is passed to `next()`, Then the global error handling middleware catches it and returns a standardized JSON error response.","Given the application setup is complete, When the main router is registered, Then all incoming API requests are directed to the main routing module.","Create and configure the main Express application instance (`src/app.ts`). This includes setting up core middleware (JSON parser, CORS), registering the main API router, and adding a global error handling middleware. The file must export the configured Express 'app' instance for use in 'index.ts'.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-2011","Domain Layer Implementation","Define the Data Model for Game Zones","Developer","As a Developer, I want a validated Mongoose schema for 'Zone' so that all game zone data is stored with a consistent structure and business rules (e.g., unique names) are enforced at the database level.","Must Have",3,"","Given I try to create a new Zone document, When the `name` field is missing, Then Mongoose throws a validation error.","Given a Zone already exists with the name 'The Forgotten Isles', When I try to create another Zone with the same name, Then the database rejects the insertion with a unique constraint violation error.","Given a new Zone document is successfully saved, When I retrieve it, Then it automatically has `createdAt` and `updatedAt` timestamp fields.","Create `src/domain/models/Zone.model.ts` with the Mongoose schema for Zone. Create `src/domain/interfaces/IZoneRepository.ts` defining data access methods. Schema must match SDS. Name field must be unique. Timestamps enabled.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-2012","Domain Layer Implementation","Define the Data Model for Game Levels","Developer","As a Developer, I want a comprehensive Mongoose schema for 'Level' so that complex level configurations, including entities and rules, can be stored reliably and linked to their parent zone.","Must Have",8,"","Given I try to save a Level document, When the `zoneId` or `levelNumber` are missing, Then Mongoose throws a validation error.","Given a level already exists for Zone 'Z1' with `levelNumber` 5, When I try to save a new level for Zone 'Z1' with `levelNumber` 5, Then the database rejects the insertion due to the compound unique index.","Given I save a Level document with valid ObjectIDs for `zoneId`, `glyphs`, and `obstacles`, When I retrieve the level data using `.populate()`, Then the referenced Zone, Glyph, and Obstacle documents are correctly populated.","Create `src/domain/models/Level.model.ts` with the Mongoose schema for Level, including references and nested objects. Create `src/domain/interfaces/ILevelRepository.ts`. Schema must handle references to Zone, Glyph, Obstacle, PuzzleType. Must include a compound unique index on {zoneId, levelNumber}.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-2013","Domain Layer Implementation","Define the Data Model for Procedural Level Instances","Developer","As a Developer, I want a Mongoose schema for 'ProceduralInstance' so that the exact configuration and solution of a procedurally generated level can be logged for reproducibility and analysis.","Must Have",3,"","Given I try to save a `ProceduralInstance` document, When the `baseLevelId` (the template) or `generationSeed` is missing, Then Mongoose throws a validation error.","Given a `ProceduralInstance` is created, When I save it with a complex JSON object for `gridConfig` and `solutionPath`, Then the data is stored correctly in the database.","Given a `ProceduralInstance` is saved, When I query it by its ID, Then I can retrieve all the details including the seed, parameters, and full grid configuration.","Create `src/domain/models/ProceduralInstance.model.ts` and `src/domain/interfaces/IProceduralInstanceRepository.ts`. Schema must reference the Level model. All fields are required as per SDS.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-2014","Domain Layer Implementation","Define Data Models for Core Game Catalogs","Developer","As a Developer, I want Mongoose schemas for 'Glyph', 'Obstacle', and 'PuzzleType' so that the fundamental building blocks of the game are defined and can be managed as catalog data.","Must Have",8,"","Given the Glyph schema is defined, When I try to create a Glyph with a `type` other than 'standard', 'mirror', 'linked', or 'catalyst', Then Mongoose throws a validation error.","Given the Obstacle schema is defined with a unique constraint on `name`, When I try to create two obstacles with the name 'Stone Wall', Then the second attempt fails with a database error.","Given the PuzzleType schema is defined, When I create a new PuzzleType document with a JSON object in the `validationRules` field, Then the object is stored correctly and can be retrieved.","Create Mongoose models for Glyph, Obstacle, and PuzzleType. Create their corresponding repository interfaces. Schemas must match SDS definitions, including enums and unique constraints.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-3011","Infrastructure Layer Implementation","Implement a Robust Database Connection Manager","DevOps Engineer","As a DevOps Engineer, I want a centralized database connection manager so that the application connects to MongoDB reliably on startup and logs its connection status for monitoring and debugging purposes.","Must Have",3,"","Given the `MONGO_URI` environment variable is set correctly, When the application starts, Then the `connectDB` function establishes a connection to the MongoDB instance and logs a 'connected' message.","Given the `MONGO_URI` is incorrect or the database is down, When the application starts, Then the connection attempt fails and an 'error' event is logged.","Given the application is running and loses its connection to the database, When the disconnection occurs, Then a 'disconnected' event is logged to the console.","Create `src/infrastructure/database/connection.ts`. This file will contain a function to connect to MongoDB using the MONGO_URI from environment variables. It should handle and log connection events. Connection should have retry logic or gracefully exit on initial failure. Must log 'connected', 'error', 'disconnected' events.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-3012","Infrastructure Layer Implementation","Implement Data Repositories for Mongoose Models","Developer","As a Developer, I want concrete repository implementations for each data model so that the application's business logic is decoupled from Mongoose, making the code more testable and easier to maintain.","Must Have",13,"US-2011,US-2012,US-2013,US-2014","Given a `MongooseLevelRepository` is instantiated, When I call its `findByZoneId` method, Then it executes `LevelModel.find({ zoneId: ... })` and returns the results.","Given a `MongooseZoneRepository` is instantiated, When I call its `findById` method, Then it executes `ZoneModel.findById(...)` and returns the resulting document.","Given any Mongoose repository is used, When a database query is performed, Then all interactions with the Mongoose model are encapsulated within that repository class.","For each model (Zone, Level, etc.), create a concrete repository implementation in `src/infrastructure/repositories/` (e.g., 'MongooseLevelRepository.ts') that implements the corresponding interface from the domain layer. Each repository class will take the corresponding Mongoose model in its constructor (for dependency injection) and implement the interface methods using Mongoose queries.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-4011","Application & Presentation Layer Implementation","Define API Data Contracts (DTOs)","Game Client Developer","As a Game Client Developer, I want well-defined Data Transfer Objects (DTOs) for all API responses so that the data contract between the client and server is stable, predictable, and free of internal server-side details.","Must Have",3,"","Given the `LevelDetailDto` is defined, When I inspect its type definition, Then it contains fields like `id`, `levelNumber`, and `gridSize`, but excludes internal fields like `__v`.","Given the `ZoneSummaryDto` is defined, When I inspect its type definition, Then it only contains a subset of fields from the full Zone model, such as `id`, `name`, and `unlockCondition`.","Given all DTOs are defined in the `src/application/dtos/` directory, When a developer needs to understand the API's output, Then they can find all relevant data structures in one place.","Create TypeScript interfaces or classes for all DTOs specified in the SDS in the `src/application/dtos/` directory. This includes ZoneSummaryDto, LevelSummaryDto, LevelDetailDto, ContentCatalogDto, etc. DTOs should only expose fields intended for the client, hiding internal data like database-specific fields.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-4012","Application & Presentation Layer Implementation","Implement Business Logic in Application Services","Developer","As a Developer, I want to encapsulate business logic within Application Services so that use cases are clearly separated from API and data access concerns, leading to a more organized and testable codebase.","Must Have",8,"US-3012,US-4011","Given the `LevelService` and a mocked `ILevelRepository`, When the `getLevelById` method is called, Then it calls the repository's `findById` method and correctly maps the returned domain model to a `LevelDetailDto`.","Given the `ContentCatalogService`, When its `getFullCatalog` method is called, Then it calls the repositories for Glyphs, Obstacles, and PuzzleTypes and aggregates the results into a single `ContentCatalogDto`.","Given any service is instantiated, When it's created, Then it receives its repository dependencies through its constructor, enabling dependency injection.","Create service classes for LevelService, ZoneService, ContentCatalogService, and ProceduralInstanceService in `src/application/services/`. These services will contain the core business logic, using repositories to fetch data and mapping it to DTOs. Services will receive repository interfaces via their constructor for dependency injection.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-4021","Application & Presentation Layer Implementation","Expose Game Content Business Logic via API Controllers","Game Client Developer","As a Game Client Developer, I want stable and predictable API controllers for game resources (Levels, Zones, etc.) so that I can easily fetch the necessary data to render the game world and puzzles.","Must Have",8,"US-4012","Given a request is made to an endpoint managed by a resource controller, When the corresponding service returns data successfully, Then the controller responds with a 2xx status code and a JSON body containing the correct DTO.","Given a request is made with invalid parameters (e.g., malformed ID), When the request is processed, Then the controller returns a 4xx client error status code with a helpful error message.","Given the underlying service throws an unexpected error, When the controller processes the request, Then the error is passed to the global error handling middleware and a 500 server error response is returned.","Create controller classes in `src/api/controllers/` for each main resource (Levels, Zones, etc.). Controllers will handle HTTP request/response, call the appropriate application service, and manage error handling. Controllers receive services via constructor injection. Methods must be async and use try-catch blocks, passing errors to the 'next' function.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-4022","Application & Presentation Layer Implementation","Define API Request Routing","Game Client Developer","As a Game Client Developer, I want a versioned and logically structured set of API routes so that I can access different game content resources through intuitive and consistent URLs (e.g., `/api/v1/zones/:id`).","Must Have",5,"US-4021","Given a GET request to `/api/v1/levels/:id`, When the request is received by the server, Then it is correctly routed to the `getById` method on the `LevelController`.","Given a POST request to `/api/v1/procedural-instances`, When the request is received by the server, Then it is correctly routed to the `create` method on the `ProceduralInstanceController`.","Given a request to a non-existent route like `/api/v1/foo`, When the request is received, Then the server responds with a 404 Not Found status.","Create Express router files in `src/api/routes/` for each resource. These files will map URL paths and HTTP methods to the corresponding controller methods. A main router will aggregate all resource routers under the `/api/v1` prefix. Routes must match the API specification exactly.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-5011","Testing & Quality Assurance","Establish a Robust Testing Environment","Developer","As a Developer, I want a fully configured Jest testing environment so that I can write and run unit and integration tests for the TypeScript codebase efficiently.","Should Have",3,"US-1011","Given the project is set up, When I run the `npm test` command, Then Jest executes all files ending in `.test.ts` within the `src` directory.","Given an integration test suite needs a database, When the tests start, Then a `mongodb-memory-server` instance is automatically started before the tests run and stopped after they complete.","Given a Jest configuration file (`jest.config.js`) exists, When tests are run, Then TypeScript code is correctly transpiled on-the-fly using `ts-jest`.","Configure Jest for TypeScript using 'ts-jest'. Set up a test script in package.json and configure 'mongodb-memory-server' for integration tests. Jest should be able to transpile and run TypeScript test files. A setup file for handling the in-memory database connection is created.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-5012","Testing & Quality Assurance","Ensure Business Logic Correctness with Unit Tests","Developer","As a Developer, I want to write unit tests for all application services so that I can verify the correctness of business logic in isolation and prevent regressions.","Should Have",13,"US-4012","Given a `LevelService` unit test, When the service's `getLevelById` method is called, Then I can assert that the mocked repository's `findById` method was called with the correct ID.","Given an application service unit test, When the mocked repository returns data, Then I can assert that the service correctly transforms the domain model into the expected DTO structure.","Given an application service unit test, When the mocked repository throws an error, Then I can assert that the service correctly catches and re-throws or handles the error as expected.","For each application service, write unit tests. Mock the repository dependencies to isolate the service's business logic. Jest's mocking framework should be used to provide mock implementations of repositories.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-5013","Testing & Quality Assurance","Verify API Behavior with Integration Tests","QA Engineer","As a QA Engineer, I want to write integration tests for all API endpoints so that I can verify the complete request-response cycle, including database interactions, ensuring the API behaves as specified.","Should Have",13,"US-4022,US-5011","Given the API is running with an in-memory database, When I send a GET request to `/api/v1/zones` using `supertest`, Then I receive a 200 OK status and a response body that is an array of ZoneSummaryDto objects.","Given the integration test setup, When I create a record in the database and then send a GET request to retrieve it by its ID (e.g., `/api/v1/levels/:id`), Then the response body contains the data for the record I just created.","Given the API is running, When I send a request with an invalid body to a POST endpoint, Then I receive a 400 Bad Request status code and a JSON error message.","Use 'supertest' to write integration tests for the API endpoints. These tests will make actual HTTP requests to the running application (connected to an in-memory DB) and assert the responses. Tests must manage test data setup and teardown in the in-memory database for each test suite.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-6011","Deployment & Documentation","Containerize the Application for Deployment","DevOps Engineer","As a DevOps Engineer, I want a Dockerfile for the service so that I can build a portable, self-contained image for consistent deployment across different environments.","Should Have",5,"US-1012","Given the Dockerfile is in the project root, When I run `docker build .`, Then it successfully creates a Docker image without errors.","Given the Docker image has been built, When I run the image as a container, Then the Node.js application starts up, connects to the database (via environment variables), and listens on the exposed port.","Given the Dockerfile uses a multi-stage build, When I inspect the final image, Then it does not contain build-time dependencies like TypeScript or `devDependencies`, resulting in a smaller image size.","Write a multi-stage Dockerfile to build and run the application. The build stage will transpile the TypeScript, and the final stage will copy the build artifacts and run the Node.js server. Should use an official Node.js image. Must correctly handle 'node_modules' caching and use a non-root user for security.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-6012","Deployment & Documentation","Automate Quality Checks with a CI Pipeline","Developer","As a Developer, I want a Continuous Integration (CI) pipeline so that code quality checks, tests, and builds are run automatically on every push, providing fast feedback and preventing broken code from being merged.","Should Have",5,"US-5011,US-6011","Given a CI pipeline configuration exists (e.g., GitHub Actions), When I push code to a branch, Then the pipeline is automatically triggered.","Given the CI pipeline is running, When the linting or testing step fails, Then the entire pipeline run fails and reports the error.","Given all steps in the CI pipeline succeed, When the pipeline completes, Then a Docker image is successfully built and a success status is reported.","Create a CI pipeline that triggers on pushes to the main branch. The pipeline should install dependencies, run linter/formatter checks, execute the test suite, and build the Docker image. The pipeline should fail if any step (lint, test, build) fails.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
"US-6013","Deployment & Documentation","Provide Live, Interactive API Documentation","Game Client Developer","As a Game Client Developer, I want browsable, interactive API documentation (like Swagger/OpenAPI) so that I can easily understand and test the available endpoints without needing to read the backend source code.","Should Have",5,"US-4022","Given the application is running, When I navigate to the `/api-docs` endpoint in a browser, Then a Swagger UI interface is displayed.","Given the API documentation is open, When I view the details for the `GET /api/v1/zones` endpoint, Then it accurately displays the path, parameters, and the structure of the `ZoneSummaryDto` response.","Given the interactive documentation, When I use the ""Try it out"" feature for an endpoint, Then I can execute a live API request against the running service and see the response.","Implement a tool or use annotations (e.g., with a library like 'swagger-jsdoc' and 'swagger-ui-express') to generate live API documentation from the code and comments. The documentation should be served from a dedicated endpoint like '/api-docs'.","Code implemented and peer-reviewed. All acceptance criteria met. Unit and/or integration tests written and passing with sufficient coverage. Code merged into the main branch."
